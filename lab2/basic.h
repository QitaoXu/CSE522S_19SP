/** @file basic.h
 * 
 * @brief Team members: Qitao Xu, Zhe Wang, Jiangnan Liu
 * 		  The header file was generated by initializing the parameters by hand.
 *		  Qitao Xu first initialized the values then Jiangnan Liu and Zhe Wang tuned the values. 
 * 		  The use case for this header file is  
 * @par       
 */ 

#ifndef BASIC_H
#define BASIC_H

#define MILLION 1000000
#define MAX_SUBTASK_PER_TASK 20

#include <linux/sched.h> 
#include <linux/hrtimer.h>
#include <linux/ktime.h>
#include <linux/list.h>
#include <linux/sort.h>

char * mode = "calibrate";
module_param(mode, charp, 0);

enum Mode { RUN = 1, CALIBRATE };
enum Mode mode_input = CALIBRATE;

struct sched_param param;

void parse_module_param(void);
char* get_thread_name(char *str, int num);

//customized structures
struct Subtask {
	int idx_in_task; /*index of subtask within the task*/
	int idx_in_core; /*index of subtask within the core*/
	int core; /* on which core of your Raspberry Pi 3 each subtask should run, set core to -1 if no aviable core to run*/
	struct Task *parent; /*parent task of subtask*/
	int work_load_loop_count; /*init to 0 or Z+, */

	ktime_t last_release_time;  //NS!! /*initialized to 0, record the last time the subtask was released*/ //NS
	int cumul_exec_time;/* sum up the execution times of that subtask and all of its predecessors within the same task*/

	int utilization; /*divide its execution time by its task's period.*/
	int execution_time;/*execution time of subtask millisecond*/

	struct task_struct *sub_thread; /*pointer to the task_struct*/
	char* kthread_id;
	struct hrtimer* hr_timer; /* timer for the subtask*/
	int if_timer_start; /* timer for the subtask is started*/

	int relative_ddl; /*task period* subtask's execution time/task's execution time*/
	int sched_priori;  /*priority of subtask on the core*/
};

struct Task{
	int period; /*period of task millisecond*/
	int num;/* number of subtask */
	int index; /* index of task */
	int execution_time; /*execution time of all subtask*/
	struct Subtask subtask_list[MAX_SUBTASK_PER_TASK];
};

struct Core{
	int core_index; /*cpu core index */
	int num;/* number of subtask */
	struct Subtask* subtask_list[MAX_SUBTASK_PER_TASK];
};

struct sched_param{
	int sched_priority;
};

//Forward Declaration
typedef struct Subtask Subtask;
typedef struct Task Task;
typedef struct Core Core;


//Module Input
void parse_module_param() {
	if (sysfs_streq(mode, "run")) {
		mode_input = RUN;
	} else {
		mode_input = CALIBRATE;
	} 
}
#endif /* BASIC_H */