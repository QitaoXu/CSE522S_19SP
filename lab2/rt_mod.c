/** @file module.c
 * 
 * @brief Team members: Qitao Xu, Zhe Wang, Jiangnan Liu
 * 		  The header file was generated by initializing the parameters by hand.
 *		  Qitao Xu first initialized the values then Jiangnan Liu and Zhe Wang tuned the values. 
 * 		  The use case for this header file is  
 * @par       
*/ 

#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/kthread.h>
#include <linux/hrtimer.h>
#include <linux/ktime.h>
#include <linux/sched.h> 
#include <linux/delay.h>
#include <linux/sort.h>
#include <linux/slab.h>
#include "basic.h"
#include "global-config.h"

/*sort utilization from highest to lowest*/
static int util_sort(const void* l, const void* r){
	Subtask* sub1=(Subtask*)(l);
	Subtask* sub2=(Subtask*)(r);
	if(sub1->utilization>sub2->utilization) return -1;
	else if(sub1->utilization<sub2->utilization) return 1;
	else return 0;
}
/*sort relative ddl from earliest to latest, so get priority from highest to lowest*/
static int ddl_sort(const void* l, const void* r){
	Subtask* sub1=(Subtask*)(l);
	Subtask* sub2=(Subtask*)(r);
	if(sub1->relative_ddl<sub2->relative_ddl) return -1;
	else if(sub1->relative_ddl>sub2->relative_ddl) return 1;
	else return 0;
}

/* timer expiration */
enum hrtimer_restart timer_callback( struct hrtimer *timer_for_restart ) {
	int ret, i;
	for (i=0; i<num_subtask; i++) {
		if (subtask_ptrs[i]->hr_timer==timer_for_restart) {
			printk(KERN_INFO "TRY TO WAKEUP subtask %d %d", subtask_ptrs[i]->parent->index, subtask_ptrs[i]->idx_in_task);
			ret = wake_up_process(subtask_ptrs[i]->sub_thread);
			if (ret==0) {
				printk(KERN_INFO "already running");
			}
			break;
		}
	}
	return HRTIMER_NORESTART;
}

void remove_element(Subtask *array, int index, int array_length)
{
   int i;
   for(i = index; i < array_length - 1; i++) {
   	array[i] = array[i + 1];
   	array[i+1].idx_in_task=i;
   }


}
/* init */
void init_all(void){
	int i,j;
	int cpu_load[num_core]={0,0,0,0};
	int total_exec_time;
	int index=0;
	int schedulable=1;
	printk(KERN_INFO "task kmalloc_array");
  	tasks = (Task*) kmalloc_array(num_task, sizeof(Task), GFP_KERNEL);
  	if (tasks==NULL) {
    	printk(KERN_INFO "task kmalloc_array error");
  	}
  	printk(KERN_INFO "core kmalloc_array");
  	cores = (Core*) kmalloc_array(num_core, sizeof(Core), GFP_KERNEL);
  	if (cores==NULL) {
    	printk(KERN_INFO "core kmalloc_array error");
  	}
  	printk(KERN_INFO "subtask_ptrs kmalloc_array");
	subtask_ptrs = (Subtask**) kmalloc_array(num_subtask, sizeof(Subtask*), GFP_KERNEL);
	if (subtask_ptrs==NULL) {
    	printk(KERN_INFO "subtask_ptrs kmalloc_array error");
  	}

  	printk(KERN_INFO "init cores and tasks");
	cores[0] = core_0;
  	cores[1] = core_1;
	cores[2] = core_2;
  	cores[3] = core_3;

  	tasks[0] = task_0;
  	tasks[1] = task_1;
  	tasks[2] = task_2;
  	tasks[3] = task_3;

	for (i=0;i<num_task;i++){
		printk(KERN_INFO "begin at task%d in %d tasks of %d subtasks", i, num_task, tasks[i].num);
		total_exec_time = 0;
		for (j=0;j<tasks[i].num;j++){
			printk(KERN_INFO "1. //////%d %d %d %d %p", tasks[i].period, tasks[i].num, tasks[i].index, tasks[i].execution_time, tasks[i].subtask_list);
			total_exec_time = total_exec_time + tasks[i].subtask_list[j].execution_time;
			printk(KERN_INFO "2. //////%d %d %d %d %p", tasks[i].period, tasks[i].num, tasks[i].index, tasks[i].execution_time, tasks[i].subtask_list);
			tasks[i].subtask_list[j].cumul_exec_time = total_exec_time;
			printk(KERN_INFO "3. //////%d %d %d %d %p", tasks[i].period, tasks[i].num, tasks[i].index, tasks[i].execution_time, tasks[i].subtask_list);
			tasks[i].subtask_list[j].parent=&(tasks[i]);
			printk(KERN_INFO "4. //////%d %d %d %d %p", tasks[i].period, tasks[i].num, tasks[i].index, tasks[i].execution_time, tasks[i].subtask_list);
			tasks[i].subtask_list[j].utilization = tasks[i].subtask_list[j].execution_time*100/tasks[i].period;
			printk(KERN_INFO "5. //////%d %d %d %d %p", tasks[i].period, tasks[i].num, tasks[i].index, tasks[i].execution_time, tasks[i].subtask_list);
			subtask_ptrs[index] = &(tasks[i].subtask_list[j]);
			printk(KERN_INFO "6. //////%d %d %d %d %p", tasks[i].period, tasks[i].num, tasks[i].index, tasks[i].execution_time, tasks[i].subtask_list);
			index+=1;
		}
		printk(KERN_INFO "execution_time task i");	
		tasks[i].execution_time = total_exec_time;
		printk(KERN_INFO "execution_time finished");
	}

	printk(KERN_INFO "calculate relative_ddl");
	for (i=0;i<num_task;i++){
		for (j=0;j<tasks[i].num;j++){
   			tasks[i].subtask_list[j].relative_ddl = (tasks[i].period)*(tasks[i].subtask_list[j].cumul_exec_time)/(tasks[i].execution_time);
   			printk(KERN_INFO "calculate relative_ddl %d", tasks[i].subtask_list[j].relative_ddl);
   		}
  	}

	if(mode_input==RUN) {
		//init: relationship between cores and subtasks
		//greedy assign subtasks to cores
		//sort subtask based on utilization from largest to smallest
		printk(KERN_INFO "sort subtask based on utilization from largest to smallest");
		for (i=0; i<num_subtask; i++) {
			printk(KERN_INFO "//////before sort, idx_in_task:%d idx_in_core:%d core:%d utilization:%d", subtask_ptrs[i]->idx_in_task, subtask_ptrs[i]->idx_in_core, subtask_ptrs[i]->core, subtask_ptrs[i]->utilization);
		}
		sort((void*)subtask_ptrs, num_subtask, sizeof(struct subtask*), &util_sort, NULL);
		for (i=0; i<num_subtask; i++) {
			printk(KERN_INFO "//////after sort, idx_in_task:%d idx_in_core:%d core:%d utilization:%d", subtask_ptrs[i]->idx_in_task, subtask_ptrs[i]->idx_in_core, subtask_ptrs[i]->core, subtask_ptrs[i]->utilization);
		}
		for (i=0; i<num_subtask; i++){
			for (j=0; j<num_core; j++){
				printk(KERN_INFO "subtask_ptrs[%d]->utilization %d", i, subtask_ptrs[i]->utilization);
				if ((cpu_load[j]+(subtask_ptrs[i]->utilization))<100) {		
					printk(KERN_INFO "assign subtask %d to core %d", i, j);
					subtask_ptrs[i]->core = j;
					cpu_load[j]+=subtask_ptrs[i]->utilization;
					subtask_ptrs[i]->idx_in_core = cores[j].num;
					cores[j].num = cores[j].num + 1;
					break;
				} else {
					continue;
				}
			}
			if (subtask_ptrs[i]->core==-1) {
				//new schedulable test
				schedulable=0;
				remove_element(subtask_ptrs[i]->parent->subtask_list,subtask_ptrs[i]->idx_in_task,remosubtask_ptrs[i]->parent->num);
				subtask_ptrs[i]->parent->num-=1;
				printk(KERN_INFO "assign core failed, drop subtask %d", i);
			} else {
				printk(KERN_INFO "link core.subtask_list to subtask_ptrs");
				cores[subtask_ptrs[i]->core].subtask_list[subtask_ptrs[i]->idx_in_core] = subtask_ptrs[i];
			}
		}
		if(schedulable==0){
						for (i=0;i<num_task;i++){
					printk(KERN_INFO "begin at task%d in %d tasks of %d subtasks", i, num_task, tasks[i].num);
					total_exec_time = 0;
					//
					for (j=0;j<tasks[i].num&&tasks[i].subtask_list[j].core!=-1;j++){
						//
						printk(KERN_INFO "1. //////%d %d %d %d %p", tasks[i].period, tasks[i].num, tasks[i].index, tasks[i].execution_time, tasks[i].subtask_list);
						total_exec_time = total_exec_time + tasks[i].subtask_list[j].execution_time;
						printk(KERN_INFO "2. //////%d %d %d %d %p", tasks[i].period, tasks[i].num, tasks[i].index, tasks[i].execution_time, tasks[i].subtask_list);
						tasks[i].subtask_list[j].cumul_exec_time = total_exec_time;
						printk(KERN_INFO "3. //////%d %d %d %d %p", tasks[i].period, tasks[i].num, tasks[i].index, tasks[i].execution_time, tasks[i].subtask_list);
						tasks[i].subtask_list[j].parent=&(tasks[i]);
						printk(KERN_INFO "4. //////%d %d %d %d %p", tasks[i].period, tasks[i].num, tasks[i].index, tasks[i].execution_time, tasks[i].subtask_list);
						tasks[i].subtask_list[j].utilization = tasks[i].subtask_list[j].execution_time*100/tasks[i].period;
						printk(KERN_INFO "5. //////%d %d %d %d %p", tasks[i].period, tasks[i].num, tasks[i].index, tasks[i].execution_time, tasks[i].subtask_list);
						subtask_ptrs[index] = &(tasks[i].subtask_list[j]);
						printk(KERN_INFO "6. //////%d %d %d %d %p", tasks[i].period, tasks[i].num, tasks[i].index, tasks[i].execution_time, tasks[i].subtask_list);
						index+=1;
					}
					printk(KERN_INFO "execution_time task i");	
					tasks[i].execution_time = total_exec_time;
					printk(KERN_INFO "execution_time finished");
				}

				printk(KERN_INFO "calculate relative_ddl");
				for (i=0;i<num_task;i++){
					for (j=0;j<tasks[i].num;j++){
			   			tasks[i].subtask_list[j].relative_ddl = (tasks[i].period)*(tasks[i].subtask_list[j].cumul_exec_time)/(tasks[i].execution_time);
			   			printk(KERN_INFO "calculate relative_ddl %d", tasks[i].subtask_list[j].relative_ddl);
			   		}
			  	}
			  	sort((void*)subtask_ptrs, num_subtask, sizeof(struct subtask*), &util_sort, NULL);
				for (i=0; i<num_subtask; i++) {
						printk(KERN_INFO "//////after sort, idx_in_task:%d idx_in_core:%d core:%d utilization:%d", subtask_ptrs[i]->idx_in_task, subtask_ptrs[i]->idx_in_core, subtask_ptrs[i]->core, subtask_ptrs[i]->utilization);
					}
				for (i=0; i<num_subtask; i++){
					for (j=0; j<num_core; j++){
						printk(KERN_INFO "subtask_ptrs[%d]->utilization %d", i, subtask_ptrs[i]->utilization);
						if ((cpu_load[j]+(subtask_ptrs[i]->utilization))<100) {		
							printk(KERN_INFO "assign subtask %d to core %d", i, j);
							subtask_ptrs[i]->core = j;
							cpu_load[j]+=subtask_ptrs[i]->utilization;
							subtask_ptrs[i]->idx_in_core = cores[j].num;
							cores[j].num = cores[j].num + 1;
							break;
						} else {
							continue;
						}
					}

		}
		for (i=0; i<num_core; i++){
			printk(KERN_INFO "cores[%d].num=%d", i, cores[i].num);
		}

		//decide subtask order in core in an order of relative ddl from earliest to latest
		printk(KERN_INFO "decide subtask order in core in an order of relative ddl from earliest to latest");
		for (i=0; i<num_core; i++){
			printk(KERN_INFO "before sort, cores[%d].num: %d", i, cores[i].num);
			if (cores[i].num==0) {
				continue;
			}
			//sort subtask based on relative ddl from earliest to latest
			printk(KERN_INFO "sort subtask based on relative ddl from earliest to latest");
			printk(KERN_INFO "after sort, cores[%d].num: %d", i, cores[i].num);
			sort((void*)(cores[i].subtask_list), cores[i].num, sizeof(struct subtask*), &ddl_sort, NULL);
			for(j=0; j<cores[i].num; j++){
				printk(KERN_INFO "adjust idx_in_core");
				cores[i].subtask_list[j]->idx_in_core = j;
				printk(KERN_INFO "set sched_priori");
				cores[i].subtask_list[j]->sched_priori = HIGHEST_PRIORITY-(j*2+10);
			}
		}
		//for test
		for (i=0;i<num_core;i++){
			printk("num: %d", cores[i].num);
		}

		//init timer and time
		for (i=0; i<num_subtask; i++) {
			if (subtask_ptrs[i]->core==-1) {
				printk(KERN_INFO "Subtask %d has no core, no timer for it", i);
				continue;
			}
			subtask_ptrs[i]->last_release_time = ktime_set(0, 0);
			printk(KERN_INFO "hrtimer_init for subtask %d", i);
			hrtimer_init(&(timers[i]), CLOCK_MONOTONIC, HRTIMER_MODE_REL);
			printk(KERN_INFO "setup hr_timer function for subtask %d", i);
			timers[i].function = &timer_callback;
			subtask_ptrs[i]->hr_timer = &(timers[i]);
		}

	} else {
		for (i=0; i<num_subtask; i++) {
			subtask_ptrs[i]->core = subtask_ptrs[i]->parent->index;
			subtask_ptrs[i]->idx_in_core=subtask_ptrs[i]->idx_in_task;
		}
		for (i=0;i<num_core;i++){
			cores[i].core_index = tasks[i].index;
			cores[i].num = tasks[i].num;
		}
		//idx in core
		for (i=0; i<num_subtask; i++) {
			cores[subtask_ptrs[i]->core].subtask_list[subtask_ptrs[i]->idx_in_core] = subtask_ptrs[i];
			subtask_ptrs[i]->sched_priori = DEFAULT_PRIORITY;
		}
	}
}

/* subtask function */
static void subtask_run_workload(Subtask * sub) {
	int i = 0;
	for (i=0; i<sub->work_load_loop_count; i++) { 
		ktime_get();
		if (i%loop_count==0) {
			printk(KERN_INFO "RUNNING in %d loops", sub->work_load_loop_count);
		}
	}
	printk(KERN_INFO "END RUNNING");
	return;
}

/* calibrate function*/
static int calibrate_fn(void * data){
 	int core_id = *((int *)data);
 	int num_of_subtasks, i, last_loop_count;
 	ktime_t before, after, diff, exe;
 	Subtask ** core_subtasks;

 	printk(KERN_INFO "Core number is %d\n", core_id);

 	if (core_id < 0 || core_id > num_core) {
  		return - 1;
 	}
 	printk(KERN_INFO "Core number is with possible range.\n");
 	core_subtasks = cores[core_id].subtask_list;
 	num_of_subtasks = cores[core_id].num;

 	printk(KERN_INFO "Number of subtasks is %d\n", num_of_subtasks);

 	for (i = 0; i < num_of_subtasks; i++) {
  		param.sched_priority = core_subtasks[i]->sched_priori;
  		sched_setscheduler(current, SCHED_FIFO, &param);

  		// Calibrate 
		while ( core_subtasks[i]->work_load_loop_count > 0) {
	   		last_loop_count = core_subtasks[i]->work_load_loop_count;
			before = ktime_get();
	   		subtask_run_workload(subtask_ptrs[i]);
	   		after = ktime_get();
	   		diff = ktime_sub(after, before);
	   		exe = ktime_set(0, (core_subtasks[i]->execution_time) * 1000000);
	   		if (ktime_compare(diff, exe) == 1) {
	 			core_subtasks[i]->work_load_loop_count -= 1;
	   		}
	   		if (last_loop_count == core_subtasks[i]->work_load_loop_count) {
	    		break;
	   		}
	  	}
  		printk(KERN_DEBUG "Core id is %d", core_id);
  		printk(KERN_DEBUG "Task id is %d, subtask id is %d", subtask_ptrs[i]->parent->index, subtask_ptrs[i]->idx_in_task);
  		printk(KERN_DEBUG "subtask execution time is %d", subtask_ptrs[i]->execution_time);
  		printk(KERN_DEBUG "subtask utilization is %d", subtask_ptrs[i]->utilization);
  		printk(KERN_DEBUG "Loop iterations count is %d", subtask_ptrs[i]->work_load_loop_count);
 	}
 	return 0;
}

/* run function*/
static int run_fn(void * data){
	Subtask* sub = (Subtask*) data;
	ktime_t current_time, expect_next;
	while (!kthread_should_stop()){ 
		set_current_state(TASK_INTERRUPTIBLE);
		printk(KERN_INFO "1. YEILD %d %d on core%d idx_in_core%d", sub->parent->index, sub->idx_in_task, sub->core, sub->idx_in_core);
		schedule();
		printk(KERN_INFO "2. BACK RUN_FN %d %d", sub->parent->index, sub->idx_in_task);
		sub->last_release_time = ktime_get();
		printk(KERN_INFO "3. RUN subtask %d %d on core%d idx_in_core%d", sub->parent->index, sub->idx_in_task, sub->core, sub->idx_in_core);
		subtask_run_workload(sub);
		printk(KERN_INFO "4. FINISH %d %d to run on core%d idx_in_core%d", sub->parent->index, sub->idx_in_task, sub->core, sub->idx_in_core);

		//TODO: WRONG if some subtasks are dropped
  		if(sub->idx_in_task==0) { //the first one
  			expect_next = ktime_add(sub->last_release_time, ktime_set(0, sub->parent->period*MILLION));
  			current_time = ktime_get();
  			if (ktime_compare(current_time, expect_next)<0) { //current_time<expect_next
  				//hrtimer_forward(sub->hr_timer, current_time, ktime_sub(expect_next, current_time));
  				hrtimer_start(sub->hr_timer, ktime_sub(expect_next, current_time), HRTIMER_MODE_REL);
  				printk(KERN_INFO "5. FIRST TASK expect_next %lld ns; current_time %lld ns", ktime_to_ns(expect_next), ktime_to_ns(current_time));
  			} else {
  				printk(KERN_INFO "5. ERROR TASK PERIOD %d %d to run on core%d idx_in_core%d", sub->parent->index, sub->idx_in_task, sub->core, sub->idx_in_core);
  			}
  		}

  		if ((sub->idx_in_task)<((sub->parent->num)-1)) { //before the last one
  			if (sub->parent->subtask_list[(sub->idx_in_task)+1].if_timer_start==0){ 
  				sub->parent->subtask_list[(sub->idx_in_task)+1].if_timer_start = 1;
  				expect_next = ktime_add(sub->parent->subtask_list[0].last_release_time, ktime_set(0, sub->relative_ddl*MILLION));
	  			current_time = ktime_get();
	  			printk(KERN_INFO "6. expect_next %lld ns, current_time %lld ns", ktime_to_ns(expect_next), ktime_to_ns(current_time));
	  			if (ktime_compare(current_time, expect_next)<0){ //current_time<expect_next
	  				printk(KERN_INFO "7. SETUP TIMER task %d %d to run on core%d idx_in_core%d", sub->parent->index, sub->parent->subtask_list[(sub->idx_in_task)+1].idx_in_task, sub->parent->subtask_list[(sub->idx_in_task)+1].core, sub->parent->subtask_list[(sub->idx_in_task)+1].idx_in_core);
	  				hrtimer_start(sub->parent->subtask_list[(sub->idx_in_task)+1].hr_timer, ktime_sub(expect_next, current_time), HRTIMER_MODE_REL);
	  			} else {
	  				printk(KERN_INFO "7. IMMEDIATELY1 WAKE UP task %d %d to run on core%d idx_in_core%d", sub->parent->index, sub->parent->subtask_list[(sub->idx_in_task)+1].idx_in_task, sub->parent->subtask_list[(sub->idx_in_task)+1].core, sub->parent->subtask_list[(sub->idx_in_task)+1].idx_in_core);			
	  				wake_up_process(sub->parent->subtask_list[(sub->idx_in_task)+1].sub_thread);
	  			}

  			} else {
  				expect_next = ktime_add(sub->parent->subtask_list[(sub->idx_in_task)+1].last_release_time, ktime_set(0, sub->parent->period*MILLION));
	  			current_time = ktime_get();
	  			printk(KERN_INFO "6. expect_next %lld ns, current_time %lld ns", ktime_to_ns(expect_next), ktime_to_ns(current_time));
	  			if (ktime_compare(current_time, expect_next)<0){ //current_time<expect_next
	  				printk(KERN_INFO "7. SETUP TIMER task %d %d to run on core%d idx_in_core%d", sub->parent->index, sub->parent->subtask_list[(sub->idx_in_task)+1].idx_in_task, sub->parent->subtask_list[(sub->idx_in_task)+1].core, sub->parent->subtask_list[(sub->idx_in_task)+1].idx_in_core);
	  				hrtimer_start(sub->parent->subtask_list[(sub->idx_in_task)+1].hr_timer, ktime_sub(expect_next, current_time), HRTIMER_MODE_REL);
	  			} else {
	  				printk(KERN_INFO "7. IMMEDIATELY2 WAKE UP task %d %d to run on core%d idx_in_core%d", sub->parent->index, sub->parent->subtask_list[(sub->idx_in_task)+1].idx_in_task, sub->parent->subtask_list[(sub->idx_in_task)+1].core, sub->parent->subtask_list[(sub->idx_in_task)+1].idx_in_core);
	  				wake_up_process(sub->parent->subtask_list[(sub->idx_in_task)+1].sub_thread);
	  			}
  			}
  		}
	}
	return 0;
}

/* init function - logs that initialization happened, returns success */
static int simple_init (void) {
	int i, j, ret;
	parse_module_param();
	printk(KERN_INFO "enter simple_init");
	init_all();
	if(mode_input == RUN){
		printk(KERN_INFO "Current mode is run mode.");
		for (i=0; i<num_task; i++) {
			for (j=0; j<tasks[i].num; j++) {
				//init thread for subtask
				if (tasks[i].subtask_list[j].core==-1) {
					printk(KERN_INFO "Task %d subtask %d has no core, no thread for it", i, j);
				} else {
					printk(KERN_INFO "thread create for %d %d!", i, j);
					tasks[i].subtask_list[j].sub_thread = kthread_create(run_fn, 
											(void *)(&tasks[i].subtask_list[j]), 
											tasks[i].subtask_list[j].kthread_id);
					if (tasks[i].subtask_list[j].sub_thread ==NULL) {
						printk(KERN_INFO "thread create failed for %d %d!", i, j);
						return -1;
					}
					kthread_bind(tasks[i].subtask_list[j].sub_thread, tasks[i].subtask_list[j].core);
					param.sched_priority = tasks[i].subtask_list[j].sched_priori;
					ret = sched_setscheduler(tasks[i].subtask_list[j].sub_thread, SCHED_FIFO, &param);
					if (ret < 0) {
						printk(KERN_INFO "sched_setscheduler failed for %d %d!", i, j);
						return -1;
					}
				}
			}
		}
		mdelay(100);
		for (i=0; i<num_task; i++) {
			for (j=0; j<tasks[i].num; j++) {
				//TODO: WRONG if some subtasks are dropped
				if(tasks[i].subtask_list[j].idx_in_task==0) {
					printk(KERN_INFO "wake up and set timer for subtask %d, %d", i, j);
					wake_up_process(tasks[i].subtask_list[j].sub_thread);
					hrtimer_start(tasks[i].subtask_list[j].hr_timer, ktime_set(10, 0), HRTIMER_MODE_REL);
				}
			}
		}

	} else {
		printk(KERN_INFO "Current mode is calibrate mode.");
		for (i = 0; i < num_core; i++) {
			printk(KERN_INFO "kthread_create, %d", cores[i].core_index);
			calibrate_kthreads[i] = kthread_create(calibrate_fn, (void *)(&cores[i].core_index), "calibrate_kthread");
			printk(KERN_INFO "kthread_bind");
			kthread_bind(calibrate_kthreads[i], cores[i].core_index);
			printk(KERN_INFO "set param");
			param.sched_priority = 1;
			printk(KERN_INFO "sched_setscheduler");
			ret = sched_setscheduler(calibrate_kthreads[i], SCHED_FIFO, &param);
			if (ret < 0) {
				printk(KERN_INFO "sched_setscheduler failed!");
				return -1;
			}
		}
		mdelay(100);
		for (i = 0; i < num_core; i++) {
			wake_up_process(calibrate_kthreads[i]);
		}
	}
    printk(KERN_ALERT "simple module initialized\n");
    return 0;
}

/* exit function */
static int free_all(void){
	int i, j, ret;

	//stop kthread & free timer for each subtask if it has
	if (mode_input==RUN) {
		for (i=0; i<num_subtask; i++) {
			hrtimer_cancel(&(timers[i]));
		}
		for (i=0; i<num_task; i++) {
			printk(KERN_INFO "task %d subtask num %d", i, tasks[i].num);
		}
		for (i=0; i<num_task; i++) {
			for (j=0; j<tasks[i].num; j++) {
				if (tasks[i].subtask_list[j].core==-1) {
					printk(KERN_INFO "Task %d subtask %d has no core, do not stop its thread", i, j);
				} else {
					printk(KERN_INFO "%d %d to stop", i, j);
					ret = kthread_stop(tasks[i].subtask_list[j].sub_thread);
			 		if(ret == 0) {
			  			printk(KERN_INFO "%s stopped",tasks[i].subtask_list[j].kthread_id);
			  		} else if (ret < 0) {
			  			printk(KERN_INFO "%s failed to stop", tasks[i].subtask_list[j].kthread_id);
			  			return -1;
			  		}
		  		}
	  		}
		}
	}

	//free subtask_ptr, task and cores
	printk(KERN_INFO "to kfree subtask_ptrs");
	kfree(subtask_ptrs);
	printk(KERN_INFO "to kfree tasks");
	kfree(tasks);
	printk(KERN_INFO "to kfree cores");
	kfree(cores);
	return 0;
}

/* exit function - logs that the module is being removed */
static void simple_exit (void) {
	int ret;
	ret = free_all();
	if (ret != 0){
		printk(KERN_DEBUG "free_all() failed partly.\n");
	}
    printk(KERN_ALERT "simple module is being unloaded");
}

module_init (simple_init);
module_exit (simple_exit);

MODULE_LICENSE ("GPL");
MODULE_AUTHOR ("Jiangnan Liu, Qitao Xu, Zhe Wang");
MODULE_DESCRIPTION ("Enforcing Real Time Behavior");
